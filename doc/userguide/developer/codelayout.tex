\section{Code Layout}
\label{sec:code:layout}

The PyLith software suite is composed of a C++ library, Python
modules, a Python application, and a few Python preprocessing and
post-processing utilities.

\subsection{Directory Structure}

The C++, Python, and SWIG Python/C++ interface files all sit in
different directories. Similarly, the unit tests, full-scale tests,
examples and documentation are also in their own directories.

\begin{description}
\item[\filename{applications}] Top-level Python application and
  utility drivers.
\item[\filename{libsrc}] C++ source for PyLith library.
\item[\filename{modulesrc}] SWIG interface files for C++ Python
  bindings.
\item[\filename{pylith}] Python source code for PyLith Python modules.
\item[\filename{doc}] Documentation.
\item[\filename{examples}] PyLith example suite.
\item[\filename{share}] Useful settings and configuration files.
\item[\filename{unittests}] Python and C++ unit tests source
  files. Run using \filename{make check}.
\item[\filename{tests\_auto}] Full-scale tests. Run using
  \filename{make check}.
\item[\filename{tests}] Full-scale tests that require manual checking
  of results.
\item[\filename{travis}] Helper scripts for building PyLith in
  Travis-CI.
\item[\filename{m4}] Autoconf macros (link to
  geodynamics/autoconfig Git repository).
\item[\filename{playpen}] Scratch area (obsolete). Use branches for
  scratch work instead.
\end{description}

We use the Pyre Python framework to collect all user parameters and to
launch the MPI application. As a result, the top-level code is written
in Python. In most cases there is a low-level C++ object of the same
name with the low-level implementation of the object. We limit the
Python code to collection of the user parameters, some simple
checking of the parameters, and passing the parameters to the
corresponding C++ objects.

The C++ library and Python modules are organized into several
subpackages.

\begin{description}
\item[\filename{bc}] Boundary conditions.
\item[\filename{faults}] Faults.
\item[\filename{feassemble}] General finite-element formulation.
\item[\filename{fekernels}] Finite-element point-wise functions (kernels).
\item[\filename{friction}] Fault constitutive models.
\item[\filename{materials}] Material behavior, including bulk constitutive models.
\item[\filename{meshio}] Input and output.
\item[\filename{problems}] General problem formulation.
\item[\filename{topology}] Finite-element mesh topology.
\item[\filename{utils}] General utilities.
\end{description}

\subsection{PyLith Application Flow}

The PyLith application driver performs two main functions. First, it
collects all user parameters from input files (e.g., \filename{.cfg}
files) and the command line, and then it performs from simple checks
on the parameters. Second, it launches the MPI job.

Once the MPI job launches, the application flow is:
\begin{enumerate}
\item Read the finite-element mesh; \object{pylith.meshio.MeshImporter}.
  \begin{enumerate}
  \item Read the mesh (serial); \object{pylith::meshio::MeshIO}.
  \item Reorder the mesh; \object{pylith::topology::ReverseCuthillMcKee}.
  \item Insert cohesive cells as necessary (serial); \object{pylith::faults::FaultCohesive}.
  \item Distribute the mesh across processes (parallel); \object{pylith::topology::Distributor}.
  \item Refine the mesh if desired (parallel); \object{pylith::topology::RefineUniform}.
  \end{enumerate}
\item Setup the problem.
  \begin{enumerate}
  \item Preinitialize the problem by passing information from Python
    to C++ and doing minimal setup; \object{pylith.Problem.preinitialize()}.
  \item Perform consistency checks and additional checks of user
    parameters; \object{pylith.Problem.verifyConfiguration()}.
  \item Complete initialization of the problem;
    \object{pylith::problems::Problem::initialize()}.
  \end{enumerate}
\item Run the problem; \object{pylith.problems.Problem.run()}.
\item Cleanup; \object{pylith.problems.Problem.finalize()}.
  \begin{enumerate}
  \item Close output files.
  \item Deallocate memory.
  \item Output PETSc log summary, if desired.
  \end{enumerate}
\end{enumerate}

In the first step, we list the object performing the work, whereas in
subsequent steps we list the top-level object method responsible for
the work. Python objects are listed using the \object{path.class}
syntax while C++ objects are listed using \object{namespace::class}
syntax. Note that a child class may redefine or perform additional
work compared to what is listed in the parent class method.

Reading the mesh and the first two steps of the problem setup are
controlled from Python. That is, at each step Python calls the
corresponding C++ methods using SWIG. Starting with the complete
initialization of the problem, the flow is controlled at the C++
level.

\subsubsection{Time-Dependent Problem}

In a time-dependent problem, the PETSc \object{TS} object (relabeled
\object{PetscTS} within PyLith) controls the time stepping. At the
beginning of each time step, the \object{PetscTS} object calls
\object{problems::TimeDependent::prestep()}, and at the end of each
time step, it calls \object{problems::TimeDependent::poststep()}.

Within each time step, the \object{PetscTS} object calls the PETSc
linear and nonlinear solvers as needed, which call the following
methods of the C++ \object{pylith::problems::TimeDependent} object as
needed
\object{computeRHSResidual()},
\object{computeRHSJacobian()},
\object{computeLHSResidual()}, and
\object{computeLHSJacobian()}.


% End of file
