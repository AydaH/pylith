\section{Debugging}
\label{sec:developer:debugging}

Debugging PyLith can be challenging due its many dependencies and complex interaction with PETSc. The most efficient
strategy for debugging is to first try to expose the bug in a serial unit test, followed by a serial full-scale test,
and then a parallel full-scale test. This may require creating new unit tests or full-scale tests if the bug is not
exposed by current tests. The PyLith developers make extensive use debuggers, such as \filename{gdb} and
\filename{lldb}, and memory management analysis tools, such as \filename{valgrind}, to detect and squash bugs.

\subsection{Runing PyLith in a Debugger}

Running PyLith in a debugger is often an efficient way to quickly zero in on the origin of an error. To start the
\filename{gdb} debugger when running the PyLith application, simply add the command line argument
\commandline{-{}-petsc.start\_in\_debugger}. To use an alternative debugger, such as \filename{lldb}, append the name
of the debugger executable, for example \commandline{-{}-petsc.start\_in\_debugger=lldb}. By default, PETSc will try to
start the debugger in an xterm. To use an alternative terminal program, use the command line argument
\commandline{-{}-petsc.debug\_terminal=TERMINAL}. For example for the GNOME terminal, use
\commandline{-{}-petsc.debug\_terminal="gnome-terminal -x"}.

\begin{shell}[Running PyLith in a debugger]
# Start the gdb debugger when running PyLith
$ pylith --petsc.start_in_debugger

# Start the lldb debugger when running PyLith
$ pylith --petsc.start_in_debugger=lldb

# Start the gdb debugger in a GNOME terminal.
$ pylith --petsc.start_in_debugger --petsc.debug_terminal="gnome-terminal -x"
\end{shell}

\begin{shell}[Debugging with gdb]
# Set breakpoint at line: b FILE:LINE
# Set breakpoint at line 150 of Material.cc
(gdb) b Material.cc:150

# Set breakpoint at exception throw
(gdb) catch throw

# Show arguments for the current frame
(gdb) info args

# Show local variables for the current frame
(gdb) info locals

# Show the contents of a local variable: p VARIABLE
(gdb) p numFields

# Show the contents of local variable: p POINTER[0]@SIZE
# Print array of 4 values pointed to by variable values
(gdb) p values[0]@4

# Print stack trace
(gdb) backtrace
\end{shell}

\begin{shell}[Debugging with lldb]
# Set breakpoint at line: b FILE:LINE
# Set breakpoint at line 150 of Material.cc
(lldb) breakpoint set -f Material.cc -l 150

# Set breakpoint at exception throw
(lldb) break set -E C++

# Show local variables
(lldb) frame variable

# Show the contents of a local variable: frame variable VARIABLE
(lldb) frame variable numFields
# Alternatively
(lldb) p numFields

# Show the contents of an array of values: p *(TYPE(*)[SIZE)])POINTER
# Show the contents of an int array of 10 values pointed to by the variable values (int*).
(lldb) p *(int(*)[10])values
\end{shell}

It is also helpful to run the debugger when finding errors in unit tests. Note that the executable in the unit tests
build directory is a wrapper around the actual executable in the \filename{.libs} directory. Consequently, you must run
the debugger on the executable in the \filename{.libs} directory.

\important{The executables for unit tests in the build directory are wrappers that insure the current version of the
PyLith library is used with the actual executable. Thus, when running the debugger on the actual executable, be sure you
have run \commandline{make install} for the library so that the current version will be used.}

\begin{shell}[Running the debugger for a unit test]
# Run the debugger on the testbc executable
$ gdb .libs/testbc
\end{shell}


\subsection{Runing Valgrind on PyLith}

Valgrind is a useful tool for finding memory leaks, use of uninitialized variables, and invalid reads and writes to
memory. When running valgrind there are three useful command line arguments:
\begin{description}
\item[\commandline{-{}-log-file=FILENAME}] Send output to FILENAME. This does not work when running the PyLith
application because each new process wipes out the log file.
\item[\commandline{-{}-suppressions=FILE}] Omit errors matching given patterns when reporting errors. Valgrind often
reports lots of errors arising from the way OpenMPI and Python handle memory allocation and deallocation. We usually use
the Python suppression file \filename{share/valgrind-python.supp} when running valgrind.
\item[\commandline{-{}-trace-children=yes}] Continue tracing errors in subprocesses. This is important when running valgrind
on the PyLith executable, as the actual computation is done in a forked process.
\end{description}

\begin{shell}[Running Valgrind]
# Run valgrind on the testbc executable
$ valgrind --log-file=valgrind_bc.log \
  --suppressions=$HOME/src/cig/pylith/share/valgrind-python.supp .libs/testbc

# Run valgrind on the PyLith executable
$ valgrind --trace-children=yes \
  --suppressions=$HOME/src/cig/pylith/share/valgrind-python.supp pylith
\end{shell}



% End of file
