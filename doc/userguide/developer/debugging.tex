\section{Debugging}
\label{sec:developer:debugging}

Debugging PyLith can be challenging due its many dependencies and complex interaction with PETSc. The most efficient
strategy for debugging is to first try to expose the bug in a serial unit test, followed by a serial full-scale test,
and then a parallel full-scale test. This may require creating new unit tests or full-scale tests if the bug is not
exposed by current tests. The PyLith developers make extensive use debuggers, such as \filename{gdb} and
\filename{lldb}, and memory management analysis tools, such as \filename{valgrind}, to detect and squash bugs.

\subsection{Runing PyLith in a Debugger}

Running PyLith in a debugger is often an efficient way to quickly zero in on the origin of an error. To start the
\filename{gdb} debugger when running the PyLith application, simply add the command line argument
\commandline{-{}-petsc.start\_in\_debugger}. To use an alternative debugger, such as \filename{lldb}, append the name
of the debugger executable, for example \commandline{-{}-petsc.start\_in\_debugger=lldb}. By default, PETSc will try to
start the debugger in an xterm. To use an alternative terminal program, use the command line argument
\commandline{-{}-petsc.debug\_terminal=TERMINAL}. For example for the GNOME terminal, use
\commandline{-{}-petsc.debug\_terminal="gnome-terminal -x"}.

\begin{shell}[Running PyLith in a debugger]
# Start the gdb debugger when running PyLith
$ pylith --petsc.start_in_debugger

# Start the lldb debugger when running PyLith
$ pylith --petsc.start_in_debugger=lldb

# Start the gdb debugger in a GNOME terminal.
$ pylith --petsc.start_in_debugger --petsc.debug_terminal="gnome-terminal -x"
\end{shell}

\begin{shell}[Debugging with gdb]
# Set breakpoint at line: b FILE:LINE
# Set breakpoint at line 150 of Material.cc
(gdb) b Material.cc:150

# Set breakpoint at exception throw
(gdb) catch throw

# Show arguments for the current frame
(gdb) info args

# Show local variables for the current frame
(gdb) info locals

# Show the contents of a local variable: p VARIABLE
(gdb) p numFields

# Show the contents of local variable: p POINTER[0]@SIZE
# Print array of 4 values pointed to by variable values
(gdb) p values[0]@4

# Print stack trace
(gdb) backtrace
\end{shell}

\begin{shell}[Debugging with lldb]
# Set breakpoint at line: b FILE:LINE
# Set breakpoint at line 150 of Material.cc
(lldb) breakpoint set -f Material.cc -l 150

# Set breakpoint at exception throw
(lldb) break set -E C++

# Show local variables
(lldb) frame variable

# Show the contents of a local variable: frame variable VARIABLE
(lldb) frame variable numFields
# Alternatively
(lldb) p numFields

# Show the contents of an array of values: p *(TYPE(*)[SIZE)])POINTER
# Show the contents of an int array of 10 values pointed to by the variable values (int*).
(lldb) p *(int(*)[10])values
\end{shell}

It is also helpful to run the debugger when finding errors in unit tests. Note that the executable in the unit tests
build directory is a wrapper around the actual executable in the \filename{.libs} directory. Consequently, you must run
the debugger on the executable in the \filename{.libs} directory.

\important{The executables for unit tests in the build directory are wrappers that insure the current version of the
PyLith library is used with the actual executable. Thus, when running the debugger on the actual executable, be sure you
have run \commandline{make install} for the library so that the current version will be used.}

\begin{shell}[Running the debugger for a unit test]
# Run the debugger on the testbc executable
$ gdb .libs/testbc
\end{shell}


\subsection{Runing Valgrind on PyLith}

Valgrind is a useful tool for finding memory leaks, use of uninitialized variables, and invalid reads and writes to
memory. When running valgrind there are three useful command line arguments: \begin{description}
\item[\commandline{-{}-log-file=FILENAME}] Send output to FILENAME. This does not work when running the PyLith
application because each new process wipes out the log file. \item[\commandline{-{}-suppressions=FILE}] Omit errors
matching given patterns when reporting errors. Valgrind often reports lots of errors arising from the way OpenMPI and
Python handle memory allocation and deallocation. We usually use the Python suppression file
\filename{share/valgrind-python.supp} when running valgrind. \item[\commandline{-{}-trace-children=yes}] Continue
tracing errors in subprocesses. This is important when running valgrind on the PyLith executable, as the actual
computation is done in a forked process. \end{description}

\begin{shell}[Running Valgrind]
# Run valgrind on the testbc executable
$ valgrind --log-file=valgrind_bc.log \
  --suppressions=$HOME/src/cig/pylith/share/valgrind-python.supp .libs/testbc

# Run valgrind on the PyLith executable
$ valgrind --trace-children=yes \
  --suppressions=$HOME/src/cig/pylith/share/valgrind-python.supp pylith
\end{shell}

\subsection{Debugging Output}

In addition to using the debugger to inspect code and variables, it is often helpful to print fields to stdout or
inspect where a computed field does not match the expected field. Turning on this type of output is usually done by
temporarily inserting calls to a few viewing functions within the test code.

Viewing a field will print the subfield metadata, the layout of the field, and the field values. See
Section~\vref{sec:developer:petsc:section} for how to interpret the layout of a field as given by PetscSection.

\begin{cplusplus}[Viewing a field]
// Call Field::view(const char* description) method.
solution.view("Solution Field");
\end{cplusplus}

\begin{shell}[Debugging output from \object{Field::view()}]
:TODO: ADD DEBUGGING OUTPUT
\end{shell}
\todo{brad}{Add example output for Field::view().}


In tests in which we compare a computed field against one from an analytical solution using
\object{DMPlexComputeL2DiffLocal()} and the fields do not agree, it is generally helpful to determine which pieces do
not agree. The \object{DMPlex} object contains an internal switch to print the point-by-point differences while computing
the norm.

\begin{cplusplus}[Turn on debugging within \object{DMPlexComputeL2DiffLocal()}]
PetscOptionsSetValue(NULL, "-dm_plex_print_l2", "1");

// Pass DMPlex object of computed field used in DMPlexComputeL2DiffLocal.
DMSetFromOptions(solution.dmMesh());

DMPlexComputeL2DiffLocal(dm, t, query.functions(), (void**)query.contextPtrs(), solution.localVector(), &norm);
\end{cplusplus}

\begin{shell}[Debugging output from \object{DMPlexComputeL2DiffLocal()}]
:TODO: ADD DEBUGGING OUTPUT
\end{shell}
\todo{brad}{Add example output for -dm\_plex\_print\_l2.}


% End of file
